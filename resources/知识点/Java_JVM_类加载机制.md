#### 参考文章

1. 《深入理解Java虚拟机》
2. [浅析Java虚拟机结构与机制](http://blog.hesey.net/2011/04/introduction-to-java-virtual-machine.html)


### JVM类加载机制

>Class文件->（类加载器）->（方法区）内存

类加载机制主要跟**JMM中的方法区**打交道。

分为三个大步骤：

1. 加载：（类的全限定名->二进制字节流）类加载器负责；
2. 连接：（验证、准备、解析）由JVM主导控制；
3. 初始化：（类变量赋值、静态语句块）Java程序代码自主控制。

### 加载

- 类的全限定名->二进制字节流；
- 二进制字节流->**方法区**的运行时数据结构；
- Java堆区生成java.lang.class对象实例->方法区DS。

此阶段可以通过**类加载器**来完成。类加载器分为：

1. 启动类加载器：加载JVM识别的类库。底层C++实现，无法被Java程序直接引用
2. 扩展类加载器：加载扩展类库。
3. 应用程序加载器：也称作系统类加载器，加载classpath上的类库
4. 自定义类加载器：

双亲委派机制：组合而不是继承

工作过程是：加载一个类，一直交由上一级的父加载器加载，若父加载器加载不了才由此加载器加载。

好处是：保证了Java类+类加载器一起构成带有优先级的层次关系。

类+类加载器保证了一个类的唯一性。

### 验证

连接的第一阶段，目的在于确保Class文件的字节流中包含的信息符合当前虚拟的要求。

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 准备

目的：正式为**类变量**分配（方法区）内存，并设置**类变量**的初始值。

>类变量：是类的变量，被static修饰的变量（类变量是分配到方法区中）。而不是实例变量（对象实例化随对象分配到Java堆中）。

### 解析

目的：将存放在**方法区中的常量池**中的符号引用替换为**直接引用**。

>符号引用：字面量，内存布局无关。
>直接引用：直接指向地址，内存布局相关。

### 初始化

初始化动作由**类构造器`<clinit>()`方法**完成。

1. **类变量**的赋值
2. 静态语句块

>同一个类加载器下的一个类，只会被初始化一次。

何时初始化？

> a、通过new关键字、反射、clone、反序列化机制实例化对象时。
> b、调用类的静态方法时。
> c、使用类的静态字段或对其赋值时。
> d、通过反射调用类的方法时。
> e、初始化该类的子类时（初始化子类前其父类必须已经被初始化）。
> f、JVM启动时被标记为启动类的类（简单理解为具有main方法的类）。
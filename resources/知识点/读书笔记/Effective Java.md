第一章 引言
第二章 创建和销毁对象

	1. 考虑用静态工程方法代替构造器
	2. 遇到多个构造器参数时考虑用构造器
	3. 用私有共早期或者枚举类型强化Singleton属性
	4. 通过私有构造器强化不可实例化的能力
	5. 避免创建不必要的对象
	6. 消除过期的对象引用
	7. 避免使用终结方法

第三章 对于所有对象都通用的方法

	1. 覆盖equals时请遵守通用约定
	2. 覆盖equals时总要覆盖hashCode
	3. 始终要覆盖toString
	4. 谨慎地覆盖clone
	5. 考虑实现Comparable接口

第四章 类和接口

	1. 使类和成员的可访问性最小化
	2. 在共有类中使用访问方法而非公有域
	3. 使可变性最小化
	4. 复合优先于继承
	5. 要么为继承而设计，并提供文档说明，要么就禁止继承
	6. 接口优于抽象类
	7. 接口只用于定义类型
	8. 类层次优于标签类
	9. 用函数对象表示策略
	10. 优先考虑静态成员类

第五章 泛型

	1. 请不要在新代码中使用原生态类型
	2. 清除非受检警告
	3. 列表优于数组
	4. 优先考泛型
	5. 优先考虑泛型方法
	6. 利用有限制通配符来提升API的灵活性
	7. 优先考虑类型安全的异构容器

第六章 枚举和注解

	1. 用enum代替int常量
	2. 用实例域代替序数
	3. 用EnumSet代替位域
	4. 用EnumMap代替序数索引
	5. 用接口模拟可伸缩的枚举
	6. 注解优于命名模式
	7. 坚持使用Override注解
	8. 用标记接口定义类型

第七章 方法

	1. 检查参数的有效性
	2. 必要时进行保护性拷贝
	3. 谨慎设计方法签名
	4. 慎用重载
	5. 慎用可变参数
	6. 返回零长度的数组或者集合，而不是null
	7. 为所有导出的API元素编写文档注释

第八章 通用程序设计

	1. 将局部变量的作用域最小化
	2. for-each循环优于传统for循环
	3. 了解和使用类库
	4. 如果需要精确的答案，请避免使用float和double
	5. 基本类型优先于装箱基本类型
	6. 如果其他类型更合适，则尽量避免使用字符串
	7. 当心字符串连接的性能
	8. 通过接口引用对象
	9. 接口优先于反射机制
	10. 谨慎地使用本地方法
	11. 谨慎地进行优化
	12. 遵守普遍接受的命名惯例

第九章 异常

	1. 只针对异常的情况才使用异常
	2. 对可恢复的情况使用受检异常，对编程错误使用运行时异常
	3. 避免不必要地使用受检地异常
	4. 优先使用标准的异常
	5. 抛出与抽象相对应的异常
	6. 每个方法抛出的异常都要有文档
	7. 在细节消息中包含能捕获失败的信息
	8. 努力使失败保持原子性
	9. 不要忽略异常

第十章 并发

	1. 同步访问共享的可变数据
	2. 避免过度同步
	3. executor和task优先于线程
	4. 并发工具优先于wait和notify
	5. 线程安全性的文档化
	6. 慎用延迟初始化
	7. 不要依赖于线程调度器
	8. 避免使用线程组

第十一章 序列化

	1. 谨慎地实现Serializable接口
	2. 考虑使用自定义的序列化形式
	3. 保护性地编写readObject方法
	4. 对于实例控制，枚举类型优先于readResolve
	5. 考虑用序列化代理代替序列化实例


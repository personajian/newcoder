#### 参考文章

1. 《深入理解JVM》
1. [JVM内存的那些事](http://www.jianshu.com/p/eaef248b5a2c)
2. [浅析Java虚拟机结构与机制](http://blog.hesey.net/2011/04/introduction-to-java-virtual-machine.html)

## JMM

### 2.2　运行时数据区域

- 线程共享：
  - 堆（Heap）:OutOfMemoryError
  - 方法区（Method Area）:OutOfMemoryError
- 线程私有：
  - 程序计数器（Program Counter Register）:唯一没有规定OutOfMemoryError的区域
  - 虚拟机栈（VM Stack，java方法）： OutOfMemoryError, StackOverflowError
  - 本地方法栈（Native Method Stack，本地方法）：OutOfMemoryError,StackOverflowError
>OutOfMemoryError（内存泄漏）：虚拟机可以动态扩展，如果扩展是无法申请到足够的内存时；  
>StackOverflowError（栈溢出）：线程请求的栈深度大于虚拟机所允许的深度时；  

#### 2.2.1　程序计数器

程序计数器（Program Counter Register）:是一块很小的内存空间，可以看作是*当前线程*做执行的*字节码*的**行号指示器**。
**字节码指示器**工作时就是*通过改变这个计数器的值来选取下一条需要执行的字节码指令*（分支、循环、跳转、异常处理、线程恢复等基础功能都是依赖于这个计数器来完成的。）。
Java虚拟机的多线程是通过**线程轮流切换**并分配处理器执行时间的方式来实现的，在确定的*时刻*，一个处理器都只会处理的一个线程中的指令。
因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，互不影响，独立存储，这类的内存区域称为“线程私有”的内存。

#### 2.2.2　Java虚拟机栈

Java虚拟机栈也是线程私有的，生命周期与线程相同。
描述的是**Java方法执行的内存模型**：
- 每个方法在执行时都会创建一个栈帧（Stack Frame）用于存储*局部变量表*、*操作数栈*、*动态链接*、*方法出口* 等信息。
- 每一个方法**从调用直至完成**的过程，就对应一个栈帧在*虚拟机栈*中的入栈到出栈的过程。

#### 2.2.3　本地方法栈

与Java虚拟机栈所发挥的作用是非常相似的，区别在于：
>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，  
>而，本地方法栈则为：虚拟机所用到的Native方法服务。  

#### 2.2.4　Java堆

**所有线程共享**的一块内存区域。唯一目的就是：**存放对象实例**；
Java堆是**垃圾回收器**管理的主要区域，又称“GC堆”：（Garbage Collected Heap）;
- 内存回收角度：
  - 分代回收算法
  - 粗分：新生代、老年代
  - 细分：Eden空间、From Survivor空间、To Survivor空间等。（后两者用于Minor GC时的对象复制）
- 内存分配角度：线程共享的Java堆可能划分出**多个线程私有的分配缓冲区**（Thread Local Allocation Buffer，TLAB）

#### 2.2.5　方法区

>字节码中方法表；  
>方法区是线程共享的，用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、*即时编译器编译后的代码*的数据。  
>HotSpot虚拟机的GC分代收集器扩展至当方法区，使用永久代来实现方法区——所以又称为“永久代”（Premanent Generation）。这个区域的内存回收目标主要是：针对常量池的回收和对类型的卸载。  

方法区虽然称为 *非堆* ，但实际在内存之中，也是一种特殊的**堆**。

>堆是专门用来存放对象的，而方法区（一种特殊的堆）是用来 *存在描述方法信息* 的**对象**。

**方法区**存放着类的运行时数据：
1. 静态变量（静态域）
2. 静态方法
3. 常量池
4. 类的代码

<-
**堆**存放着对象：
- java.lang.class:代表着方法区的类（java中万物皆对象：Class也是对象。）

<-
**栈**main方法的栈帧：


#### 2.2.6　运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池**（Constant Pool Table），用于存放编译期生成的*各种字面量和符号引用*，这部分内容将在类加载后进入方法区的运行时常量池中存放。

#### 2.2.7　直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。
>NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库来直接分配**堆外内存**，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。显著提高性能，因为避免了Java堆和Native堆中来回复制数据。

### HotSpot虚拟机

#### 2.3.1 对象的创建

步骤：类加载检查->新生对象分配内存->内存空间初始化->对象头设置->`<init>()`构造器

类加载检查：

新生对象分配内存：
- 对象内存大小完全确定
- 由于Java堆中内存绝对规整，分配内存方式分为：
	- 指针碰撞
	- 空闲列表
- 并发情况下分配内存：
	- CAS保证原子性
	- TLAB（Thread Local Allocation Buffer）：线程本地分配缓冲

内存空间初始化：初始化为零值，对象头除外。

对象头设置：
- 对象头（Object Header）：

`<init>()`：初始化，真的可用的对象才完全产生出来。

#### 2.3.2 对象的内存布局

三块区域：
- 对象头：运行时数据+类型指针
	- 运行时数据区：数据长度32bit或64bit，Mark Word
		1. 哈希码
		2. GC分代年龄
		3. 锁状态标志
		4. 线程持有的锁
		5. 偏向线程ID
		6. 偏向时间戳
	- 指针类型：对象指向它的类元数据的指针。
- 实例数据：对象真正存储的信息，也就是各种类型的字段内容
- 对齐填充：仅作占位符，内存地址必须是8字节的整数倍

#### 2.3.3 对象的访问地位

句柄、直接地址。
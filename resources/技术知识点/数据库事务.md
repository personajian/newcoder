[TOC]

## 数据库事务

### ACID

1. 原子性
2. 一致性
3. 隔离性
4. 持久性

**一致性**是最终目标。
**重执行日志**保证原子性、一致性和持久性。

### 数据并发

数据并发带来的五类问题：

- 3类数据读问题：（都是事务A在读时，事务B发生了事务提交/未提交。）

    1. 脏读：读到尚未提交事务的更改数据。（未提交）
    2. 不可重复读：读到已提交事务的**更改**数据。（提交新增）
    3. 幻象读：读到其他已提交事务的**新增**数据。（提交更改）

>不可重复读->更改（删除）->行->行级锁。  
>幻象读->新增->表->表级锁。

- 2类数据更新问题：

    1. 第一类丢失更新：事务**撤销**，覆盖其他事务已提交的数据->丢失了更新（撤销致丢失）。
    2. 第二类丢失更新：事务**提交**，覆盖其他事务已提交的数据->丢失了更新（提交致丢失）。

### 锁机制

- 按锁定对象不同，分为：

    1. 表级锁
    2. 行级锁
    
- 并发事务锁定的关系上，分为：

    1. 共享锁定（共享型封锁，S锁，Shared lock）
    2. 独占锁定（排他型封锁，X锁，Exclusive lock）
    
**行共享锁定->行独占锁定->表共享锁定->表共享行锁定->表独占锁**。（锁定范围从大到小，锁定优先级）

### 事务的存取模式

1. READ ONLY（只读型）：事务对数据库的操作只能是读操作。
2. READ WRITE（读写型）：事务对数据库的操作可以是读操作，也可以是写操作。默认此模式。

### 事务隔离级别

事务隔离级别和数据库并发性是对象的，两者此消彼长。（隔离性越强，并发性越低。）

ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别（由弱到强）：

1. READ UMCOMMITED：会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 ) 
2. READ CONMITED： 会出现不可重复读、幻读问题（锁定正在读取的行）
3. REPEATABLE READ：会出幻读（锁定所读取的所有行） 
4. SERIALIZABLE：保证所有的情况不会发生（锁表）

事务级别对并发问题的解决情况：

名称|隔离级别|锁机制|脏读|不可重复读|幻象读|第一类丢失更新|第二类丢失更新
---|---|---|---|---|---|---|---
读未提交|READ UMCOMMITED|无锁|允许|允许|允许|不允许|允许
读已提交|READ CONMITED|行共享锁|不允许|允许|允许|不允许|允许
可重复读|REPEATABLE READ|行独占锁定|不允许|允许|不允许|不允许|不允许
可串行化|SERIALIZABLE|表独占锁|不允许|不允许|不允许|不允许|不允许


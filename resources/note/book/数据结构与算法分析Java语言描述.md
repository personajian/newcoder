---
title: 《数据结构与算法分析Java语言描述》
tags: []
notebook: A01-读书笔记
---
[TOC]

[《数据结构与算法分析Java语言描述 原书第3版》.pdf](evernote:///view/7665708/s44/f873968c-71e2-4807-b859-deba3cd2adc1/f873968c-71e2-4807-b859-deba3cd2adc1/)

## 第四章 树

### 4.1 二叉查找树是TreeSet,TreeMap的实现基础。

  * 树的表示方法：兄弟孩子表示法。
  * 树的遍历：

目录结构->一条边就是一个全路径名；非叶子结点都是目录，叶子结点都是文件。  
遍历目录ls：就是**先序遍历**的应用之处。对结点的处理工作是在它的诸些子节点被处理前（pre）进行的。  
计算文件占用磁盘区块个数：目录亦是文件：子目录+目录=区块总数。->这是**后序遍历**应用的优势所在。

### 4.2 二叉树

  * 平均深度：O(N^-2)
  * 二叉查找树：O(logN)  
>->因为树将结点关系一分为N(叉)。树结构本身就降低了复杂度。  
>->但是不平衡的树依然O(N)。  
>->维持树的平衡很重要！！
  * 应用：编译器表达式：中序、后序、先序的实现。

### 4.3 查找ADT：二叉查找树

  * **结构：左小右大**

  * contains();findMin();findMax();remove()

>->但是由于insert();remove()操作导致树的深度无线增加，线性增长。  
>->于是，引出平衡树——平衡查找树AVL。（较旧的方法：平衡查找树；较新的方法：自调整的伸展树。）

* AVL树：深度必须是O(logN)

插入操作：会破坏AVL树的特征->引出旋转操作：单旋转；双旋转。

>->其实，O(N)的查找并不坏。

### 4.4 伸展树：不存在坏的输入序列下，伸展树性能不差。

### 4.5 ->内存装不下树，什么数据结构能够来存储、查找磁盘数据呢？

> （寻道时间、旋转时间：旋转磁盘、移动磁头），导致读取速度跟不上内存，速度慢。

->所以，机会留给了数据结构的实现，虽然实现由难度的，但是值得。

  * M叉查找树：M路分支
  * 完全二叉树：log2(N)
  * 完全M叉树：logM(N)-
  * B+(B)树：就应运而生！（二叉树，其实树的引出主要是为了查找，提高查找效率。）

### 4.6 **标准库中的集合与映射**

  * Set接口-->TreeSet;SortedSet
  * Map接口-->TreeMap;SortedMap
  * containsKey();get();put()  

>->因为Map本身是不存在迭代器的

于是，遍历Map值的方法是：将Map对象的视图作为Collection对象返回。有三种方法：
    
    
    1)Set keySet():键 对象视图。  
    2)Collection values():值 对象视图。  
    3)Set<Map.Entry<keyType,valueType>> entrySet():键值对实体对象视图（返回Set集合，因为键值对对象是肯定不重复的！）。
    

> TreeSet;TreeMap:add();remove();contains()

基本实现：平衡二叉查找树；自顶向下的红黑树。

>->那迭代器如何高效的实现呢？遍历的效率开销降低呢？

于是引出了：线索二叉树，来实现迭代。

  * 那TreeMap还不够快？怎么办？
  * ->引出Map的散列实现：HashMap
  * ->引出Set的散列实现：HashSet
  * （其实Set的底层就是Map：键值对Map中的vaule全为null—>Map就退化成为了Set，键对象保证了Set是对象是不重复的。）

必须提供equals();hashCode()方法。

## 第五章 散列

>查找树ADT->散列表ADT：只支持二叉查找树所允许的一部分操作；不支持findMin();findMax();排序打印。

### 5.1 一般想法

**散列函数：**关键字-*映射*->0~TableSize-1大小的适当单元中。  
**冲突：**关键字散列到了同一值时，应该做什么？如何确定散列表的大小？
>分离链接法、开放定址法。

### 5.2 散列函数

* 通常*关键字*是**字符串**。

### 5.3 分散链接法

* 将散列到同一值的所有元素保留到一个**表（链表）**中。  
* 插入到链表的前端：新近插入的元素最有可能不久被访问。

>二叉查找树只对是Comparator对象工作  
>->  
>**散列表只对提供了适当的equals()和返回int型的hashCode()方法的那些对象工作。**

### 5.4 探测散列表：不用链表的散列表

* 线性探测法：但是会出现*一次聚集*；

>->为了解决一次聚集的问题！
 
* 平方探测法：但是会出现*二次聚集*；

>->为了解决二次聚集的问题！

* 再散列：采用建立另一个大约两倍长的表。
    1. 表满一半就散列；
    2. 只有插入失败再散列；
    3. 途中散列：达到装填因子

### 5.6 标准库中的散列表

* Set->HashSet
* Map->HashMap

>关键字对象必须提供：equals()和hashCode()；  
>HsahMap的性能常常优于TreeMap；  

* String类对象的hashCode()方法：
> 因为散列表操作中费时最多的部分就是计算hashCode方法。  
 
于是，String类对象的内部都存储了hashCode的值。  ——caching the hash code：闪存散列代码；缓存哈希代码。*经典的时空交换！*  
之所以有效是因为：String类不可改变的。

### 5.7 最坏情况下O(1)访问的散列表

期望插入、删除和查找的平均花销都是O(1)。

* 完美散列
* 布谷鸟散列
* 跳房子散列

### 5.8 通用散列法

* 通用散列函数
* 卡特-韦格曼绝招

### 5.9 可扩散列

>使得使用两次磁盘访问执行一次查找。  
>位模式是均匀分布的。



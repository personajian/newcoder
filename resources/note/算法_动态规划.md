[TOC]

## 漫谈动态规划（Dynamic Programming）

### 0. 动态规划的本质

动态规划的本质，是对问题**状态的定义**和**状态转移方程的定义**。  
引自维基百科


> dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.
> 

动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。

1. 拆分问题（break it）定义出-->
2. 问题状态和状态之间的关系（relationship）-->
3. solve（递推、分治的求解方法？）。


核心在于：**如何拆分问题？！** ，而拆分问题，靠的就是**状态的定义和状态转移方程的定义**。

### 1. 什么是状态的定义？

- 状态的定义：非原问题，数学化定义。

### 2. 什么是状态转移方程？

- 状态转移方程：状态之间的关系式（带有条件的递推式）。

### 3. 动态规划迷思

- “缓存”、“重叠子问题”、“记忆化”仅仅是作为递推式求解的技巧，旨在花费空间来节省时间。
- 递归——递推式求解的方法（连技巧都不算）。
- 无后效性、最优子结构（隐含条件，否则根本定义不出）：
    - 有后效性不代表不适用动态规划
    - 寻找符合“最优子结构”的状态以及状态转移方程的定义，记忆化地求解递推式。
    - 所以，寻找定义才是动态规划的本质！

> 动态规划是寻找一种对问题的观察角度，让问题

## 关于动态规划中最优子结构及后效性的疑问

### 0. 动态规划的本质

动态规划的本质不在于是递推或者递归，也不需要纠结是不是内存换时间。

> 动态规划是对于某一类问题的解决方法！

重点在于**如何鉴定“某一类问题”是动态规划可解的，而不是纠结解决方法是递归还是递推！**

### 1. 状态的概念

计算机的工作（本质）：计算机->状态机

> 内存存储所有数据=当前的状态--（CPU计算出）-->下一个状态。

利用计算机解决问题时，其实在思考**如何将问题表达成状态**：
- 哪些变量存储哪些数据？
- 以及如何在状态中转移？
- 怎样根据一些变量--（计算出）-->另一些变量？

*空间复杂度*——为了支持计算必需存储的状态最多有多少？

*时间复杂度*——从初始状态-->最终状态：中间需要多少步？

> 例如：计算斐波那契数列  
> 每一个斐波那契数<-->这个问题的一个状态。  
> 每求一个新数字只需要之前的两个状态-->递推！

### 2. 阶段的概念

阶段的概念：指随着问题的解决，在同一时刻可能会得到的不同**状态**的集合。

> 例如围棋问题中：  
> 1. 走了几步就是第几个**阶段**，走了几步可能处于的位置称为一个**状态**。
> 2. 走了几步所有可能到达的*位置集合*，就是*这个阶段所有可能的状态*。  
> - 特殊的是，斐波那契的一个阶段只有一个状态而已。

### 3.引入阶段与状态之后

引入阶段与状态的概念后，计算新状态遇到各种不同的情况。（不同情况，用不同的算法）  
假设：  
- 问题有几个阶段; 
- 每个阶段有多个状态;  
- 不同阶段的状态数不必相同;
- 一个阶段的一个状态-->下个阶段的所有状态中的几个！

于是：计算最终阶段的状态数，需经历之前每个阶段的某些状态。  
**好消息是，有时候我们并不需要真的计算所有状态！**

比如一个弱智的模型问题：从棋盘的左上角到达右上角最短需要多少步？

1. 某个阶段可以有多个状态<-->走n步可以走很多位置
2. 但同步数的n步中，有哪些位置-->第n+1步走的最远？正是第n步中走的最远的位置。
3. “下一步最优是从当前最优得到的”

> 所以，为了计算最终的最优值，只需要存储每一步的最优即可。——贪心算法。

最优状态之间的计算过程与斐波那契数列计算很像。（计算方法是递推）

于是我们解决了“一个阶段的最优可以由前一阶段的最优得到”这一大类问题。

### 4.最麻烦的情况

最麻烦的情况在于：**需要之前所有的情况才能得到当前最优**。

>后效性：之前的路线会影响下一步的选择。

但契机正在于后效性！有一类问题，看似需要之前的所有状态，其实不用！！

例如：
最长上升子序列：
```math
LIS(i)=max{LIS(j)+1} \space \space \space \space \space j<i \space and \space a[j]<a[i]
```
所以一个问题是该用*递推、贪心、搜索还是动态规划*，完全是有这个问题本身**阶段间状态的转移方式**决定的。

- 每个阶段只有一个状态->递推；
- 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
- 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
- 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划

> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到

这个性质叫做**最优子结构**；

> 而不管之前这个状态是如何得到的

这个性质叫做**无后效性**。

另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。  
但实际上有的问题往往需要

1. 对每个阶段的所有状态都算出一个最优值，
2. 然后根据这些最优值再来找最优状态。

比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。



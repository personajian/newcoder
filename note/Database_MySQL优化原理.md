[TOC]

#### 参考文章

1. 《高性能MySQL》
2. [我必须得告诉大家的MySQL优化原理](http://www.jianshu.com/p/d7665192aaaf)
3. [我必须得告诉大家的MySQL优化原理2](http://www.jianshu.com/p/01b9f028d9c7)
4. [我必须得告诉你的MySQL优化原理3](http://www.jianshu.com/p/78b6b7e2bb7f)
5. [由 B-/B+树看 MySQL索引结构](https://segmentfault.com/a/1190000004690721)
6. [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
7. [从 MongoDB 及 Mysql 谈B/B+树](http://blog.csdn.net/wwh578867817/article/details/50493940)
8. []()
9. []()

## [我必须得告诉大家的MySQL优化原理](http://www.jianshu.com/p/d7665192aaaf)

MySQL的查询优化，相信大家收藏了一堆奇技淫巧：
1. 不能使用SELECT *
2. 不使用NULL字段
3. 合理创建索引
4. 为字段选择合适的数据类型
5. 。。


### 1. MySQL逻辑架构

MySQL逻辑架构整体分为三层：

1. 客户端层：并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。
2. 核心服务层：包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。
3. 存储引擎：其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。


### 2. MySQL查询过程

MySQL整个查询执行过程，总的来说分为6个步骤：

1. 客户端向MySQL服务器发送一条查询请求
2. 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
3. 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
4. MySQL根据执行计划，调用存储引擎的API来执行查询
5. 将结果返回给客户端，同时缓存查询结果

#### 客户端/服务端通信协议

“半双工”：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。

>在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。

#### 查询缓存

查询缓存能提高系统性能，但是缓存和失效也会带来额外消耗。（查询缓存非常大或者碎片很多）

查询缓存，并在数据库设计上做一些优化，比如：

1. 用多个小表代替一个大表，注意不要过度设计
2. 批量插入代替循环单条插入
3. 合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适
4. 可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存

#### 语法解析和预处理

MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。


#### 查询优化

MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。

MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：

1. 重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）
2. 优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）
3. 提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）
4. 优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再4根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）

#### 查询执行引擎

在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。

#### 返回结果给客户端

结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。

### 3. 性能优化建议

1. Scheme设计与数据类型优化
2. 创建高性能索引

### 索引相关的算法与数据结构

#### B+Tree

索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如**InnoDB就是使用的B+Tree**。

B+Tree中的B是指balance，意为平衡。

需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。

二叉查找数->平衡二叉树->多路平衡查找树->B-Tree->B+Tree。

MySQL选用B+Tree作为索引存储结构的重要原因：

1. B+tree是多路平衡查找树。严格控制树高，IO代价小。
2. B+Tree的每个节点设置为一个页的整数倍，每个节点能够存储更多的内节点 ，索引范围更大。
2. B+Tree的所有的叶子节点由指针连接。方便MySQL的区间查找。

#### B+Tree维护平衡

插入新节点时，为了维持平衡，可能导致页拆分。

但通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类型，仍然需要旋转和拆分操作。

### 高性能策略

1、MySQL不会使用索引的情况：非独立的列

2、前缀索引

3、多列索引和索引顺序

4、避免多个范围条件

5、覆盖索引

6、使用索引扫描来排序

7、冗余和重复索引

8、删除长期未使用的索引

### 特定类型查询优化

优化COUNT()查询

优化关联查询

优化LIMIT分页

优化UNION


## [我必须得告诉大家的MySQL优化原理2](http://www.jianshu.com/p/01b9f028d9c7)

### 分区表

1. 合理索引能够极大提升查询性能，但是数据量巨大的时候，索引维护（磁盘空间、I/O操作）的代价也会非常大
2. ->分表：
    - 垂直拆分（比如：不同订单状态的订单拆分到不同的表）
    - 水平拆分（比如：按月将订单拆分到不同表）
    - 但是提升了编码难度 
3. ->分区表：

MySQL底层帮我们实现分表，分区表是一个独立的逻辑表，底层由多个物理子表组成。

存储引擎管理分区的各个底层表和管理普通表一样（所有底层表必须使用相同的存储引擎），分区表的索引也是在各个底层表上各自加上一个完全相同的索引。

从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道。在执行查询时，优化器会根据分区的定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区，只需要查找包含需要数据的分区就可以了。

在使用分区表时，为了保证大数据量的可扩展性，一般有两个策略：

1. 全量扫描数据，不用索引。即只要能够根据WHERE条件将需要查询的数据限制在少数分区中，效率是不错的
2. 索引数据，分离热点。如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独存放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以值访问一个很小的分区表，能够使用索引，也能够有效的利用缓存。

上面两个分区策略基于两个非常重要的前提：

1. 查询都能够过滤掉很多额外的分区
2. 分区本身并不会带来很多额外的代价。

而这两个前提在某些场景下是有问题的，比如：

1、NULL值会使分区过滤无效
2、分区列和索引列不匹配
3、选择分区的成本可能很高
4、打开并锁住所有底层表的成本在某些时候会很高
5、维护分区的成本可能会很高

### 视图

### 存储过程与触发器

### 外键约束

### 绑定变量

### 用户自定义函数

### 字符集


## [我必须得告诉你的MySQL优化原理3](http://www.jianshu.com/p/78b6b7e2bb7f)

### MySQL配置
[TOC]

# 算法之查找

- 高效检索
- 经典查找算法
- 符号表：一张抽象的表格——将**信息（值）**存储在其中，然后按照指定的**键**来搜索并获取信息。有时称作：字典表、索引表。

三种高效的数据结构：
1. 二叉查找树
2. 红黑树
3. 散列表

## 符号表

> 符号表是存储键值对的DS（数据结构）。

> 符号表实现的重点在于：其中使用的数据结构和get()、put() 方法。

> 有序符号表保持键的有序性。

1. 链表（顺序查找）：适用小型表；大型表很慢。
1. 有序数组（二分查找）：有序、查找快；插入慢。
1. 二叉查找树：有序、查找快；没有性能上界的保证、需要额外链表空间。
1. 平衡二叉查找树（红黑树）：有序、最优查找和插入；额外链表空间。
1. 散列表：快速查找和插入；无序、散列函数。

## 二叉查找树

二叉查找树的特点：

- 将**链表插入的灵活性**+**有序数组查找的高效性**结合！
- 每个结点含有两个链接。
- 查找和删除都很简单。
- 递归调用前，沿树向下走
- 递归调用后，沿树向上走
- 完全平衡的情况下：lgN，但是最坏的情况下是N
- 二叉查找树和快速排序是“双胞胎”

## 平衡查找树

> 正是由于二叉查找树在最坏情况下（可能很不平衡）的恶劣性能是不可接受的，所以维持二叉查找树的平衡是至关重要的。但是，在动态插入的保证树的完美平衡的代价太高了。

平衡二叉查找树就能保证无论键的插入顺序如何，树的高度总是总键数的对数（lgN）。

### 2-3查找树

2-3查找树含有：

- 2-结点（一个键、两个链接）
- 3-结点（两个键、三个链接）

一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。

操作有：

- 查找
- 向2-结点中插入新键：
- 向一棵只含有一个3-结点的树中插入新键：
- 向一个父结点为3-结点的3-结点插入新键：
- 分解根结点
- 局部变换：不会影响到树的全局有序性和平衡性。
- 全局性质：

### 红黑二叉查找树（Red Black Balance Search Tree）

#### 1. 替换3-结点

红黑二叉查找树背后的基本思想是利用：

- **标准的二叉查找树（完全由2-结点构成）** 

- **一些额外的信息（替换3-结点）** 

来表示2-3查找树。

将树中的链接分为两种类型：

- **红链接**：将两个2-结点连接起来构成一个3-结点。
- **黑链接**：2-3查找树中的普通链接。

确切的说，将*3-结点*表示为由**一条左斜的红色链接**相连的*两个2-结点*。（两个2-结点其中一个是另一个的左结点）

#### 2. 等价定义

所以，红黑树是满足以下三个条件的2-3树：

- [ ] 红链接均为左链接。
- [ ] 没有任何一个结点同时和两条红链接相连。
- [ ] 该树是完美黑色平衡的，即任意空链接到根结点的路径上黑链接数量相同。

> 将一棵红黑树的红链接画平，那么所有空链接到根结点的距离都将是相同的。

#### 3. 一一对应

红黑树和2-3树之间一一对应：

1. 将红黑树中的，由红链接相连的结点合并，得到的就是一棵2-3树。
2. 将一棵2-3树中的3-结点画作由红色左链接相连的两个2-结点。

所以，无论用何种方式定义，红黑树既是二叉查找树，也是2-3树。结合二叉查找树的高效查找和2-3树中的平衡插入。

#### 4. 相关操作

1. 颜色表示：每个结点都只会有一条**指向自己的链接**。

2. 旋转：在某些操作中可能会出现*红色右链接*或者*两条连续的红链接*，就会在操作完成前被旋转修复。右链接左旋转、左链接右旋转，在旋转后重置父结点的链接。

旋转操作保证了红黑树的两个重要性质：有序性+完美平衡性

3. 颜色转换：颜色局部变换并不会影响到整棵树的黑色平衡性。

- 子结点：红->黑
- 父结点：黑->红

4. 根结点总是黑色：每当根结点由红被变黑时，树的高度都会加1。

5. 向单个2-结点中插入新键

- 若新键小于老键，只需新增一个红色结点即可，新的红黑树和单个3-结点完全等价；
- 若新键大于老键，那么新增的红色结点将会产生一个红色的右链接，需要将其旋转成为红色左链接并修正根结点的链接。

6. 向树底部的2-结点插入新键

-  若指向新结点的是父结点的左链接，那么父结点就直接成为一个3-结点；
-  若指向新结点的是父结点的右链接，这就是一个错误的3-结点，但一次左旋转就能够修正它。

7. 向一棵双键树（即一个3-结点）中插入新键

形成的连续两条红链接，由红变黑。

- 新键最大
- 新键最小
- 新键介于两者之间

8. 向树底部的3-结点插入新键

将红链接在树中向上传递：每次必要的旋转之后，都会进行颜色转换，使得中结点变红。

9. 删除操作：构造临时4-结点时沿着查找路径*向下*进行变换，还要在分解遗留的4-结点是沿着查找路径*向上*进行变换。

#### 红黑树的性质

- **基于红黑树的符号表实现都能保证操作的运行时间在对数级别。**
- 红黑树实现的复杂仅仅限于：插入和删除操作。
- 二叉查找树中的查找最大键和最小键、select()、rank()、floor()、ceiling()和范围查找等方法，不用作任何修改就可以在红黑树中直接使用。

## 4 散列表

键->数组索引->数组中的键值对。

散列查找分为两步：

1. 散列函数将键转化为索引；
2. 处理碰撞冲突（拉链法和线性探测法）。

散列算法的参数可以在空间和时间之间做出取舍。

散列表拥有：常数级别的查找和插入操作。

### 散列函数

- 键->数组索引。
- 除留余数法
- 重写equals()，必须重写hashCode()。
- equals是hashCode的充分不必要条件。
- hashCode()的返回值转化为一个数组索引：最终的哈希值还是要落在一定的数组范围内。
- 软缓存

优秀的散列方法满足下面三个条件：

1. 一致性
2. 高效性
3. 均匀性


### 解决碰撞冲突

1. 基于拉链法的散列表
2. 基于线性探测法的散列表（开放定址法）


## 5 应用





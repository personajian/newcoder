
### 帅潘版

>快排的时间复杂度

平均情况：O(nlogn)，切分均衡，轴点接近中央；
最坏情况：O(n^2)，切分极不均衡。

>如何确保快排的时间复杂度为O(nlogn）

快速切分算法（quick partition）——构造出轴点，能将原向量划分为左右两个子向量。
轴点选取：随机法、三者取中法。

>查找第一大和第二大的数的比较次数


>多线程的实现方式

1. 继承Thread类，重写run()方法；
2. 实现Runnable接口，重写run()方法；
3. 实现Callable接口，

>CAS和Synchronized的底层比较

- Synchronized编译之后，会在同步块前后分别形成monitorenter和monitorexit两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。
- CAS底层是通过Unsafe的CAS()方法实现的，是Native方法，调用了C++代码：更具当前处理器类型来决定是否为cmpxchg指令添加lock前缀。如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀。
    1. 确保对内存读写操作的原子执行。
    2. 禁止指令重排序。
    3. 把写缓冲区的所有数据刷新到内存中。

上面的第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。

>200T的电话号码中找到是否存在某个号码



>如何高效统计网站的在线人数（存在高并发）


>Java的Fork/Join

并行计算的框架，典型实现就是MapReduce。

>基于的Java的编程语言

Scala、Kotlin、Clojure、Jython、JRuby

>垃圾收集器

- 串行：Serial, Serial Old
- 并行：ParNew, Parallel Old
- 高吞吐量：Parallel Scaverge
- 低停顿：CMS
- G1

>Java命令行指令有哪些

javac java jar

### [高并发分布式系统中生成全局唯一Id汇总](http://www.jianshu.com/p/1be3f15cbc57)

推荐做法：

1. Snowflake：时间序列+机器标识+计数顺序号
2. 专门数据库MySQL自带自增

#### 一、twitter——时间序列+机器标识+计数顺序号

twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。

1. 41位的时间序列（精确到毫秒，41位的长度可以使用69年）
2. 10位的机器标识（10位的长度最多支持部署1024个节点）
3. 12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。

优点：高性能，低延迟；独立的应用；按时间有序。 缺点：需要独立的开发和部署。

#### 二、来自Flicker——MySQL的单表专门做auto_increment

因为MySQL本身支持auto_increment操作，很自然地，我们会想到借助这个特性来实现这个功能。

Flicker在解决全局ID生成方案里就采用了MySQL自增长ID的机制（auto_increment + replace into + MyISAM）。一个生成64位ID方案具体就是这样的：

先创建单独的数据库(eg:ticket)，然后创建一个表：

当我们插入记录后，执行SELECT * from Tickets64，查询结果就是这样的：

在我们的应用端需要做下面这两个操作，在一个事务会话里提交：

这样我们就能拿到不断增长且不重复的ID了。

到上面为止，我们只是在单台数据库上生成ID，从高可用角度考虑，接下来就要解决单点故障问题：Flicker启用了两台数据库服务器来生成ID，通过区分auto_increment的起始值和步长来生成奇偶数的ID。

最后，在客户端只需要通过轮询方式取ID就可以了。
优点：充分借助数据库的自增ID机制，提供高可靠性，生成的ID有序。
缺点：占用两个独立的MySQL实例，有些浪费资源，成本较高

#### 三 UUID

UUID生成的是length=32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。

算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成UUID。

从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复

优点：
（1）本地生成ID，不需要进行远程调用，时延低
（2）扩展性好，基本可以认为没有性能上限
缺点：
（1）无法保证趋势递增
（2）uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

#### 四 基于redis的分布式ID生成器

首先，要知道redis的EVAL，EVALSHA命令：
原理
利用redis的lua脚本执行功能，在每个节点上通过lua脚本生成唯一ID。
生成的ID是64位的：
使用41 bit来存放时间，精确到毫秒，可以使用41年。
使用12 bit来存放逻辑分片ID，最大分片ID是4095
使用10 bit来存放自增长ID，意味着每个节点，每毫秒最多可以生成1024个ID

[TOC]

## 第一章 引言

## 第二章 创建和销毁对象

### 1. 考虑用静态工程方法代替构造器

### 2. 遇到多个构造器参数时考虑用构造器

### 3. 用私有共早期或者枚举类型强化Singleton属性

### 4. 通过私有构造器强化不可实例化的能力

### 5. 避免创建不必要的对象

### 6. 消除过期的对象引用

### 7. 避免使用终结方法

## 第三章 对于所有对象都通用的方法

### 1. 覆盖equals时请遵守通用约定

equals逻辑相等:自反性、对称性、传递性、一致性、非空性


### 2. 覆盖equals时总要覆盖hashCode

equals逻辑相等-->hashCode物理相等


### 3. 始终要覆盖toString

简洁的，但信息丰富，并且易于阅读的表达形式


### 4. 谨慎地覆盖clone

### 5. 考虑实现Comparable接口

具有内在的排序关系（natural ordering）


## 第四章 类和接口

### 1. 使类和成员的可访问性最小化

信息隐藏或封装，默认包级私有（default）

### 2. 在共有类中使用访问方法而非公有域

getXxx(),setXxx()

### 3. 使可变性最小化

可变类final：String、基本类型的包装类型、BigInteger和BigDecimal


### 4. 复合优先于继承

继承打破了封装性；复合，包装类


### 5. 要么为继承而设计，并提供文档说明，要么就禁止继承

### 6. 接口优于抽象类

接口是定义mixin（混合类型）的理想选择


### 7. 接口只用于定义类型

应该用来被用来导出常量

### 8. 类层次优于标签类

### 9. 用函数对象表示策略

### 10. 优先考虑静态成员类

嵌套类：静态成员类、非静态成员类、匿名类和局部类（内部类）

## 第五章 泛型

### 1. 请不要在新代码中使用原生态类型
List<E>相对应的原生态类型是List

### 2. 清除非受检警告

泛型带来的，尽可能地消除每一个非受检警告；抑或@SuppressWarnings("unchecked")注解来禁止警告

### 3. 列表优于数组

数组是协变的（covariant）；泛型是不可变的（invariant），互不子类型或超类型 

### 4. 优先考泛型

静态工具方法尤其适合于泛型化（Collections所有的算法都泛型化了）

### 5. 优先考虑泛型方法

集合API限制了每个容器只能有固定数目的类型参数；

### 6. 利用有限制通配符来提升API的灵活性

### 7. 优先考虑类型安全的异构容器

而通过将键(key)进行参数化而不是将容器(container)参数化：Class<T> type

## 第六章 枚举和注解

### 1. 用enum代替int常量

### 2. 用实例域代替序数

### 3. 用EnumSet代替位域

### 4. 用EnumMap代替序数索引

### 5. 用接口模拟可伸缩的枚举

### 6. 注解优于命名模式

元注解，标记注解

### 7. 坚持使用Override注解

### 8. 用标记接口定义类型

## 第七章 方法

### 1. 检查参数的有效性

### 2. 必要时进行保护性拷贝

### 3. 谨慎设计方法签名

- 谨慎地选择方法的名称；
- 不要过于追求提供便利的方法；
- 避免多长的参数列表

### 4. 慎用重载

### 5. 慎用可变参数

### 6. 返回零长度的数组或者集合，而不是null

### 7. 为所有导出的API元素编写文档注释

## 第八章 通用程序设计

### 1. 将局部变量的作用域最小化

最有利的方法就是在第一次使用它的地方声明

### 2. for-each循环优于传统for循环

- foreach循环不仅遍历集合和数组，还可以遍历任何实现Iterable接口的对象
- 三种情况无法使用foreach循环：过滤、转换、平行迭代（仅遍历，不修改）

### 3. 了解和使用类库

- Collections Framework(集合框架)，java.util.concurrent(并发实用工具)

### 4. 如果需要精确的答案，请避免使用float和double

- 二进制浮点运算。取而代之，使用BigDecima、int或者long进行货币计算

### 5. 基本类型优先于装箱基本类型

- 基本类型（primitive）：int、double和boolean等；
- 引用类型（reference type）：String、List等；
- 每个基本类型都有一个对应的引用类型-->装箱基本类型（boxed primitive）

### 6. 如果其他类型更合适，则尽量避免使用字符串

### 7. 当心字符串连接的性能

- 为连接n个字符串而重复使用字符串连接操作符，需要n平方级的时间；
- 为了获得可以接受的性能，请使用StringBuilder替代String


### 8. 通过接口引用对象

- 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明；
- 没有合适的接口存在，考虑类值（value class）、基类（base class）

### 9. 接口优先于反射机制

### 10. 谨慎地使用本地方法

### 11. 谨慎地进行优化

### 12. 遵守普遍接受的命名惯例

字面惯例：

标识符类型|命名惯例|例子
---|---|---
包|包名小写|com.google.inject, org.joda.time.format
类或者接口|首字母大写|Timer, FutureTask, LinkedHashMap, HttpServlet
方法或者域|驼峰命名|remove, ensureCapacity, getCrc
常量域|大写|MIN_VALUE, NEGATIVE_INFINITY
局部变量|小写|i, xref, houseNumber
类型参数|单字母大写|T, E, K, V, X, T1, T2

语法惯例：

- -able: Runnable、Iterable、Accessible
- is-: isDigit、isProbablePrime、isEmpty、isEnabled、hasSiblings
- get-, set-, toType, asType, typeValue
- 静态工厂：valueOf、of、getInstance、newInstance、getType、NewType


## 第九章 异常

### 1. 只针对异常的情况才使用异常

### 2. 对可恢复的情况使用受检异常，对编程错误使用运行时异常

### 3. 避免不必要地使用受检地异常

### 4. 优先使用标准的异常

### 5. 抛出与抽象相对应的异常

### 6. 每个方法抛出的异常都要有文档

### 7. 在细节消息中包含能捕获失败的信息

### 8. 努力使失败保持原子性

### 9. 不要忽略异常

## 第十章 并发

### 1. 同步访问共享的可变数据

### 2. 避免过度同步

### 3. executor和task优先于线程

### 4. 并发工具优先于wait和notify

### 5. 线程安全性的文档化

### 6. 慎用延迟初始化

### 7. 不要依赖于线程调度器

### 8. 避免使用线程组

## 第十一章 序列化

### 1. 谨慎地实现Serializable接口

### 2. 考虑使用自定义的序列化形式

### 3. 保护性地编写readObject方法

### 4. 对于实例控制，枚举类型优先于readResolve

### 5. 考虑用序列化代理代替序列化实例


